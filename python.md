## 闭包

在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包。

## 面向对象

OOP，是一种编程的思想。OOP把对象当成一个程序的基本单元，一个对象包含了数据和操作数据的函数。

### 1、封装（Encapsulation）

封装，顾名思义就是将内容封装到某个地方，以后再去调用被封装在某处的内容。 

### 2、继承（Inheritance）

继承，面向对象中的继承和现实生活中的继承相同，即：子可以继承父的内容。

### 3、多态（Polymorphism）

首先Python不支持多态，也不用支持多态，python是一种多态语言，崇尚鸭子类型。

### 优劣势

优点：
  ``1``、使程序更加容易扩展和易更改，使开发效率变得更高(对某个对象类属性的修改，会立刻反映到整个体系中)  
  ``2``、基于面向对象的程序可以使他人更加容易理解代码逻辑。
缺点：
  编程复杂度高、可控性差（无法像面向过程程序那样精准预测问题处理过程与结果，对象之间的交互，比较难预测最终的结果）

### 深度优先和广度优先

在子类继承多个父类时，属性查找方式分深度优先和广度优先两种。

- 当类是经典类时，多继承情况下，在要查找属性不存在时，会按照深度优先方式查找下去。
- 当类是新式类时，多继承情况下，在要查找属性不存在时，会按照广度优先方式查找下去。



## 进程与线程的区别

1. 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；

2. 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；

3. 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见；

4. 调度和切换：线程上下文切换比进程上下文切换要快得多；

## 深拷贝和浅拷贝的区别

在创建新实例类型时使用浅拷贝，并保留在新实例中复制的值。**浅拷贝用于复制引用指针**，就像复制值一样。这些引用指向原始对象，并且在类的任何成员中所做的更改也将影响它的原始副本。浅拷贝允许更快地执行程序，它取决于所使用的数据的大小。

**深拷贝用于存储已复制的值**。深拷贝不会将引用指针复制到对象。它引用一个对象，并存储一些其他对象指向的新对象。原始副本中所做的更改不会影响使用该对象的任何其他副本。由于为每个被调用的对象创建了某些副本，因此深拷贝会使程序的执行速度变慢。

## python下多线程的限制

python多线程有个全局解释器锁（global interpreter lock），这个锁的意思是任一时间只能有一个线程使用解释器，跟单cpu跑多个程序一个意思，大家都是轮着用的，这叫“并发”，不是“并行”。 　　

## python多线程与多进程的区别

- 在UNIX平台上，当某个进程终结之后，该进程需要被其父进程调用wait，否则进程成为僵尸进程(Zombie)。所以，有必要对每个Process对象调用join()方法 (实际上等同于wait)。对于多线程来说，由于只有一个进程，所以不存在此必要性。
- 多进程应该避免共享资源。在多线程中，我们可以比较容易地共享资源，比如使用全局变量或者传递参数。在多进程情况下，由于每个进程有自己独立的内存空间，以上方法并不合适。此时我们可以通过共享内存和Manager的方法来共享资源。但这样做提高了程序的复杂度，并因为同步的需要而降低了程序的效率

## python的内存管理机制

### 一、对象的引用计数机制

Python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。

引用计数增加的情况：

1，一个对象分配一个新名称

2，将其放入一个容器中（如列表、元组或字典）

引用计数减少的情况：

1，使用del语句对对象别名显示的销毁

2，引用超出作用域或被重新赋值

sys.getrefcount( )函数可以获得对象的当前引用计数

多数情况下，引用计数比你猜测得要大得多。对于不可变数据（如数字和字符串），解释器会在程序的不同部分共享内存，以便节约内存。

### 二、垃圾回收

1，当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。

2，当两个对象a和b相互引用时，del语句可以减少a和b的引用计数，并销毁用于引用底层对象的名称。然而由于每个对象都包含一个对其他对象的应用，因此引用计数不会归零，对象也不会销毁。（从而导致内存泄露）。为解决这一问题，解释器会定期执行一个循环检测器，搜索不可访问对象的循环并删除它们。（即**标记清除、分代回收**）

### 三、内存池机制

Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。

Pymalloc机制。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。

1.Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的malloc。

2.对于Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。

# 未整理资料

https://www.lanqiao.cn/questions/102676/?utm_source=baidu&utm_medium=cpc&utm_campaign=python&utm_term=keywords